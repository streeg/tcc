\newcommand{\texCommand}[1]{\texttt{\textbackslash{#1}}}%

\newcommand{\exemplo}[1]{%
\vspace{\baselineskip}%
\noindent\fbox{\begin{minipage}{\textwidth}#1\end{minipage}}%
\\\vspace{\baselineskip}}%

\newcommand{\exemploVerbatim}[1]{%
\vspace{\baselineskip}%
\noindent\fbox{\begin{minipage}{\textwidth}%
#1\end{minipage}}%
\\\vspace{\baselineskip}}%


% Trabalho recentemente publicado sobre analise dinamica (in run time)

\section{Trabalhos Correlatos e Revisão de Literatura}

\subsection{Criptografia} %https://www.techtarget.com/searchsecurity/definition/cryptography

O conceito do dicionário de criptografia é a prática de proteger informações e comunicações por meio do uso de códigos, hashes, assinaturas, para que apenas aqueles para quem as informações são destinadas possam lê-las e processá-las.
No contexto de ciência da computação, de acordo com Kathleen Richards \cite{what_is_cryptography} a criptografia se refere a técnicas seguras de informações e comunicações derivadas de conceitos matemáticos e de um conjunto de cálculos baseados em regras chamados algoritmos, para transformar mensagens de maneiras difíceis de decifrar.
A criptografia moderna preocupa-se com quatro objetivos principais: confidencialidade, integridade, não repúdio e autenticação.
\begin{itemize}
  \item confidencialidade. A informação não pode ser entendida por ninguém além de quem a mensagem foi destina.
  \item Integridade. A informação não pode ser alterada de forma alguma entre o remetente e o destinatário sem que isso seja detectado.
  \item Não Repudiação. O remetente não pode negar o envio da informação.
  \item Autenticação. O remetente e o destinatário devem poder confirmar a identidade de cada um.
\end{itemize}

Existem diversos algoritmos de criptografia, dentre eles podemos citar o Advanced Encryption Standard (AES), o RSA, o Elliptic Curve Digital Signature Algorithm (ECDSA) e o Digital Signature Algorithm (DSA) \cite{what_is_cryptography}.

Apesar da importância da criptografia para a segurança dos sistemas, muitos desenvolvedores se deparam com desafios significativos ao tentar implementá-la corretamente. Sem o conhecimento especializado em criptografia, é possível utilizar erroneamente algoritmos e técnicas criptográficas inadequadas. \cite{cryptographic_software_fail} \cite{api_misuses_zhang} Isso pode resultar em vulnerabilidades que comprometem a segurança e a privacidade dos dados dos usuários. Portanto, é essencial contar com ferramentas que possam orientar os desenvolvedores na aplicação correta das práticas criptográficas, reduzindo assim os riscos associados à implementação inadequada de medidas de segurança em software.\cite{api_misuses_zhang}

\subsection{Análise dinâmica de APIs criptográficas} %Runtime Verification of Crypto APIs: An Empirical Study

O estudo realizado por Torres et al. \cite{runtime_verification_crypto} fornece uma importante investigação comparativa de métodos de detecção de uso inadequado de APIs criptográficas em projetos Java.

A pesquisa conduzida oferece uma análise detalhada das técnicas empregadas, incluindo a abordagem de Verificação em Tempo de Execução (Runtime Verification, ou RVSec), juntamente com notáveis analisadores estáticos como CogniCrypt e CryptoGuard, além da ferramenta CryLogger.

Este estudo desempenha um papel complementar para a nossa própria investigação. Ele não apenas fornece uma visão sobre as técnicas de detecção de vulnerabilidades em APIs criptográficas, mas também motiva a explorar uma perspectiva complementar em relação as ferramentas de análises estáticas. 

\subsection{Detecção de vulnerabilidades em APIs criptográficas Java} %Automatic Detection of Java Cryptographic API Misuses: Are We There Yet?

O artigo intitulado "Automatic Detection of Java Cryptographic API Misuses: Are We There Yet?" \cite{api_misuses_zhang} aborda os desafios enfrentados pelos desenvolvedores ao trabalhar com APIs criptográficas Java. 

Na análise feita por Zhang, é destacado questões como a complexidade das APIs, a falta de documentação adequada e a falta de treinamento em segurança cibernética por parte dos desenvolvedores \cite{api_misuses_zhang} como as principais causas de vulnerabilidades nos códigos. 

Ele ainda destaca que muitos desenvolvedores podem não possuir o treinamento em cibersegurança necessário para compreender plenamente as implicações de segurança ao utilizar as opções de codificação dentro das APIs criptográficas. 

Nos exemplos citados no artigo temos os desenvolvedores não estarem completamente cientes dos valores adequados para serem utilizados como parâmetros de funções criptográficas, das sequências de chamadas corretas ou da lógica de substituição, o que pode resultar na implementação insegura de funcionalidades de segurança \cite{api_misuses_zhang}, a prática de copiar e colar trechos de código de fontes online, como o StackOverflow sem ter total entendimento do que está sendo copiado.

% Fontes:

% Página 1: As interfaces de programação de aplicativos (APIs) oferecidas por esses frameworks visam facilitar a programação segura dos desenvolvedores, como a geração de chaves e o estabelecimento de comunicações seguras. No entanto, as APIs na realidade não são fáceis de usar por duas razões. Primeiro, algumas APIs são excessivamente complexas, mas mal documentadas [3]–[5]. Segundo, os desenvolvedores carecem do treinamento em cibersegurança necessário; eles desconhecem as implicações de segurança das opções de codificação (por exemplo, os valores de parâmetros, sequências de chamadas ou lógica de substituição das APIs) [5]–[8]. Consequentemente, muitos desenvolvedores usaram as APIs criptográficas de maneira inadequada, construíram funcionalidades de segurança de forma insegura e introduziram vulnerabilidades ou fraquezas no software.
% Página 2: A plataforma Java fornece dois frameworks importantes para possibilitar a implementação de segurança: JCA e JSSE. O JCA oferece APIs para implementar conceitos de criptografia, como assinaturas digitais, resumos de mensagens, certificados e sua validação, criptografia, geração e gerenciamento de chaves, e geração segura de números aleatórios [1]. O JSSE permite comunicações seguras pela internet; ele inclui APIs para criação de canais seguros, criptografia de dados, autenticação de servidor, integridade de mensagens e autenticação opcional de cliente [2]. Entre todas as APIs definidas no JCA e JSSE, existem 13 tipos de Java (ou seja, classes ou interfaces) frequentemente mencionados nos padrões de uso inadequado de API resumidos por pesquisas anteriores [10]–[12], [15], [17], [26], [27].

% A exemplo das vulnerabilidades identificadas pelo estudo, podemos citar:

% Os desenvolvedores frequentemente utilizavam parâmetros inadequados em métodos como Cipher.getInstance(), MessageDigest.getInstance() e SecretKeyFactory.getInstance(), indicando a utilização de algoritmos criptográficos quebrados ou arriscados, potencialmente expondo informações sensíveis \cite{api_misuses_zhang}.

% Houve casos em que os desenvolvedores empregaram métodos inseguros para gerar chaves criptográficas, comprometendo a segurança dos processos de criptografia e descriptografia e facilitando possíveis ataques \cite{api_misuses_zhang}.

% Foi observado que o gerenciamento de chaves criptográficas muitas vezes deixou a desejar. Isso incluiu práticas como a codificação rígida de chaves no código-fonte, o armazenamento em locais inseguros e o uso de mecanismos de armazenamento de chaves frágeis, o que poderia resultar em acessos não autorizados a dados sensíveis \cite{api_misuses_zhang}.

% Em algumas situações, os desenvolvedores falharam na inicialização correta de objetos criptográficos, como definir o modo ou preenchimento adequado para algoritmos de criptografia. Essas falhas poderiam levar a processos de criptografia ou descriptografia vulneráveis, tornando o sistema suscetível a ataques \cite{api_misuses_zhang}.

% Foram encontrados casos em que os desenvolvedores utilizaram métodos inseguros para gerar números aleatórios, como a classe java.util.Random em vez da mais segura java.security.SecureRandom. Essa prática poderia comprometer a segurança das operações criptográficas \cite{api_misuses_zhang}.

% Por fim, o estudo identificou situações em que os desenvolvedores não autenticavam ou validavam adequadamente operações criptográficas, como a falta de verificação de assinaturas digitais ou a validação de certificados. Isso poderia resultar na aceitação de dados forjados ou adulterados, prejudicando a integridade e autenticidade do sistema \cite{api_misuses_zhang}.

% FONTES:

% Página 2: Padrões de uso incorreto de APIs criptográficas
% Página 10: Estudo empírico em projetos Apache
% Página 13: Análise de ferramentas existentes e vulnerabilidades

O estudo ainda foi além e tentou identificar a percepção dos desenvoledores em relação a vulnerabilidades em seus códigos. 

Houveram visões divergentes em relação às ferramentas existentes para detectar usos incorretos de APIs. 

Dos feedbacks recebidos, a maioria dos desenvolvedores rejeitou as vulnerabilidades relatadas, indicando que não as consideravam válidas ou relevantes. Menos desenvolvedores demonstraram disposição para abordar os problemas reportados e fazer as correções necessárias. Ainda menos desenvolvedores efetivamente substituíram os usos incorretos de APIs com base nas orientações fornecidas pelas ferramentas \cite{api_misuses_zhang}.

Os fatores que contribuíram para a relutância dos desenvolvedores em lidar com os problemas reportados incluem: 

As sugestões de correção fornecidas pelas ferramentas muitas vezes eram vagas e incompletas, tornando difícil para os desenvolvedores compreender como corrigir os usos incorretos de forma eficaz. 

Os desenvolvedores expressaram a necessidade de evidências de exploração de segurança que pudessem ser habilitadas pelas vulnerabilidades relatadas. Eles queriam compreender o impacto potencial e a gravidade dos problemas antes de investir tempo em corrigi-los. 

Por fim, alguns dos usos incorretos detectados foram encontrados em código de teste ou em contextos de programa que não eram considerados relevantes para a segurança. Os desenvolvedores acreditavam que esses problemas não teriam consequências de segurança, levando-os a ignorá-los ou descartá-los.

No geral, o estudo revelou uma lacuna significativa entre as ferramentas existentes e as expectativas dos desenvolvedores. Os relatórios gerados pelas ferramentas não alteraram efetivamente as práticas de codificação dos desenvolvedores, e estes tinham preocupações sobre as capacidades das ferramentas, a correção das correções sugeridas e a exploração dos problemas relatados.

Assim, nosso estudo se fundamenta na análise de Zhang, e visa compreender se as vulnerabilidades identificadas pelas ferramentas CryptoGuard e CogniCrypt têm sua origem associada a bibliotecas de caráter nativo ou externo. 

% FONTES:

% Página 2: "De acordo com as 47 respostas que recebemos, a maioria dos desenvolvedores (ou seja, 30) rejeitou as vulnerabilidades relatadas, menos desenvolvedores (ou seja, 17) queriam abordar os problemas relatados e ainda menos desenvolvedores (ou seja, 9) substituíram usos inadequados de APIs seguindo orientações geradas pela ferramenta. Os relatórios das ferramentas geralmente não alteraram as práticas de codificação dos desenvolvedores."

\subsection{Detecção de bibliotecas externas em aplicações Android} %Automated Third-Party Library Detection for Android Applications: Are We There Yet?

Em outro artigo do Zhang, é realizado um estudo com foco na detecção de bibliotecas externas em aplicações android. \cite{api_tpl_zhang} Esse estudo é importante para o nosso trabalho pois ele aborda a detecção de bibliotecas externas em aplicações Android, e a partir dele foi possível identificar a ferramenta LibScout, que será utilizada para a identificação de bibliotecas externas em aplicações Android.

Durante o artigo é destacado que muitas vezes a introdução de bibliotecas de terceiros podem resultar em introdução de vulnerabilidades das quais o desenvolvedor nem está ciente. 

O estudo realizado tem como foco a detecção das bibliotecas externas. Nosso estudo se baseia nesse artigo para a escolha da ferramenta LibScout, que será utilizada para a identificação de bibliotecas externas em aplicações Android.
% Fonte:

% Zhan, X., Fan, L., Liu, T., Chen, S., Li, L., Wang, H., Xu, Y., Luo, X., & Liu, Y. (2020). Automated Third-Party Library Detection for Android Applications: Are We There Yet?. In 35th IEEE/ACM International Conference on Automated Software Engineering (ASE ’20), September 21–25, 2020, Virtual Event, Australia. ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/3324884.3416582
% FONTES:

% Página 2: "ASE ’20, 21 a 25 de setembro de 2020, Evento Virtual, Austrália X. Zhan, L. Fan, T. Liu, S. Chen, L. Li, H. Wang, Y. Xu, X. Luo, Y. Liu"
% Página 2: "ASE ’20, 21 a 25 de setembro de 2020, Evento Virtual, Austrália X. Zhan, L. Fan, T. Liu, S. Chen, L. Li, H. Wang, Y. Xu, X. Luo, Y. Liu"
% Os métodos para detectar e mitigar riscos de Bibliotecas de Terceiros em aplicações Android apresentados por Zhang, incluem whitelist de TPLs confiáveis, ferramentas de detecção que analisam características das aplicações tais como o CogniCrypt e o CryptoGuard, revisões sistemáticas da literatura para comparar técnicas, estratégias de ofuscação de código para proteção contra engenharia reversa, e o uso de conjuntos de dados relevantes disponibilizados por outros pesquisadores. 

% FONTES:

% Página 4: ASE ’20, 21 a 25 de setembro de 2020, Evento Virtual, Austrália
% Página 3: ASE ’20, 21 a 25 de setembro de 2020, Evento Virtual, Austrália
% Página 2: ASE ’20, 21 a 25 de setembro de 2020, Evento Virtual, Austrália

O estudo foi realizado com várias ferramentas para detectar bibliotecas de terceiros (TPLs) em aplicativos Android, temos: 
\begin{itemize}
  \item LibID, que utiliza análise estática e dinâmica para identificar TPLs. 
  \item LibPecker concentra-se na detecção de TPLs ofuscadas por diferentes técnicas de ofuscação de código. 
  \item ORLIS que emprega uma combinação de análise estática e dinâmica, fornecendo análise de vulnerabilidades para as TPLs identificadas. 
  \item LibRadar que utiliza análise baseada em API e é conhecido por sua rápida detecção. 
  \item LibD2, semelhante ao LibID e ORLIS, usa análise estática e dinâmica, além de fornecer análise de vulnerabilidades para as TPLs detectadas. 
\end{itemize}
  
Os programas LibID, LibRadar, LibScout, LibPecker e ORLIS foram avaliados em quatro categorias: eficiência, escalabilidade, resistência à obfuscação e facilidade de uso. 

O LibScout se destacou na eficiência, identificando 49 bibliotecas de terceiros com uma precisão de 97\%. 
Em escalabilidade, o LibRadar foi o mais eficaz, capaz de analisar cada aplicação em cerca de 5 segundos. 
No quesito resistência à obfuscação, o LibPecker mostrou-se o mais eficaz. 
Quanto à facilidade de uso, tanto o LibScout quanto o LibRadar superaram os concorrentes \cite{api_tpl_zhang}.

Devido a eficiência e escalabilidade, inicialmente optamos seguir com o LibScout e com o LibRadar. As outras ferramentas tem tempo de execução muito grande para uma precisão não tão alta.

Os resultados do LibRadar e do LibScout para o piloto não só não foram semelhantes como o LibScout identificou muito mais TPLs do que o LibRadar.

% FONTES:

% Página 9: "Para a detecção vulnerável de TPLs no aplicativo, recomendamos o LibScout, que possui melhor desempenho na identificação das versões específicas da biblioteca na detecção de TPLs."
% Página 9: "O LibScout é sensível à ofuscação do fluxo de controle, achatamento de pacotes e remoção de código inativo."
% Página 9: Tabela 5: Avaliação das capacidades das ferramentas existentes para diferentes técnicas de ofuscação de código
% Página 7: "Resposta à C3: O LibPecker supera outras ferramentas na defesa contra diferentes ofuscadores e diferentes técnicas de ofuscação."
% Página 7: "Resposta à C1: Em termos de eficácia, o LibScout se destaca."
\subsection{LibScout} % https://github.com/reddr/LibScout 

A ferramenta LibScout é resultado de um projeto de pesquisa cujo objetivo principal é analisar quais são as bibliotecas externas e quais são bibliotecas nativas em aplicativos Android. 

A ferramenta permite analisar chamadas de API de aplicativos Android diretamente do bytecode java. 

A ferramenta coleta informações detalhadas sobre bibliotecas implantadas, incluindo nomes e definições, e fornece uma visão abrangente do ecossistema de bibliotecas de cada aplicativo analisado. \cite{LibScout}

Assim, para o estudo desse artigo, a comparação dos resultados das ferramentas CryptoGuard e CogniCrypt aos resultados gerados pelo LibScout visa solucionar o problema de identificar possíveis vulnerabilidades relacionadas ao uso de bibliotecas de terceiros.

\subsection{Aplicativos obfuscados} %Automatic Detection of Java Cryptographic API Misuses: Are We There Yet?

Uma dificuldade significativa na localização e extração de informações sobre bibliotecas de terceiros é a análise de aplicativos obfuscados. O uso comum da técnica de ofuscação de código torna a compreensão e análise do código-fonte mais difíceis, tornando a localização de bibliotecas externas ainda mais complicada. \cite{api_tpl_zhang}

O LibScout é excepcionalmente resistente a aplicativos obfuscados, porém, o CryptoGuard e o CogniCrypt não. Embora essas ferramentas mais recentes detectem problemas e erros de segurança com sucesso, elas têm dificuldade em encontrar os nomes originais das bibliotecas e classes que são usadas. O processo de correlacionar os resultados e combinar os scripts de identificação de bibliotecas externas é mais difícil devido a essa restrição.

O problema acima é um dos motivos dos quais os aplicativos utilizados para montar os testes do estudo não serem obfuscados.

\subsection{O que é a ferramenta CogniCrypt?} %CogniCrypt: Supporting Developers in Using Cryptography

O CogniCrypt, desenvolvido no centro de pesquisa CROSSING da Technische Universität Darmstadt, é uma ferramenta projetada para auxiliar desenvolvedores na identificação e correção de usos inseguros de bibliotecas criptográficas em software. 

Estudos recentes têm apontado que muitos aplicativos que empregam procedimentos criptográficos o fazem de maneira inadequada, o que destaca a relevância do CogniCrypt \cite{CogniCrypt}.

Essa ferramenta integra-se ao ambiente de desenvolvimento Eclipse e oferece dois principais componentes. Primeiramente, um assistente de geração de código que auxilia os desenvolvedores na produção de código seguro para tarefas criptográficas comuns. Além disso, realiza uma análise estática contínua do código do desenvolvedor, notificando sobre possíveis usos incorretos de APIs criptográficas.

% O CogniCrypt representa um avanço significativo na segurança de aplicações Java que fazem uso de operações criptográficas. Os desenvolvedores podem empregar a linguagem CrySL, na qual a ferramenta se baseia, para definir as melhores práticas para o uso seguro das APIs criptográficas disponíveis na arquitetura Java Cryptography (JCA). Desde a seleção de algoritmos até a gestão adequada de chaves de criptografia, as CrySL Rules fornecem um conjunto abrangente de diretrizes \cite{CogniCrypt}.

% Além das análises em tempo real durante o processo de escrita, o CogniCrypt facilita a criptografia de dados, oferecendo um conjunto de ferramentas para implementar práticas de segurança de forma transparente e eficaz \cite{CogniCrypt}.

% A colaboração entre a linguagem CrySL e o CogniCrypt oferece uma abordagem abrangente para identificar e reforçar a segurança de códigos vulneráveis. Ao seguir as regras e especificações definidas em CrySL, os desenvolvedores podem identificar potenciais pontos fracos na implementação de criptografia e receber recomendações precisas para aprimorar a segurança de seus sistemas \cite{CogniCrypt}.

O CogniCrypt pode oferecer uma abordagem abrangente para abordar a identificação de vulnerabilidades no código por meio de dois recursos fundamentais: a geração de código e a aplicação de análises estáticas \cite{CogniCrypt}.

% A funcionalidade de geração de código do CogniCrypt destaca-se ao produzir implementações seguras para tarefas de programação comumente associadas à criptografia. Por meio desta característica, os desenvolvedores recebem exemplos de uso orientados por tarefas específicas das APIs criptográficas em Java. Esses exemplos são gerados com base em configurações selecionadas, que incluem o algoritmo criptográfico desejado e seus parâmetros correspondentes. Ao empregar esta capacidade, o CogniCrypt pode desempenhar um papel crucial em auxiliar os desenvolvedores na prevenção de vulnerabilidades comuns, garantindo a integração segura de componentes criptográficos em seus projetos \cite{CogniCrypt}.

% Adicionalmente, o CogniCrypt incorpora uma funcionalidade de análise estática que opera em segundo plano, aplicando uma série de análises ao projeto do desenvolvedor. Estas análises têm por objetivo assegurar que todas as utilizações das APIs criptográficas permaneçam seguras, mesmo que o desenvolvedor venha a modificar o código gerado ou utilize as APIs diretamente, sem recorrer à geração de código. O CogniCrypt se vale do framework de análise de estados TS4J, implementado como um plugin do Eclipse, para efetuar a inspeção do projeto. Ele reporta discrepâncias na utilização por meio da geração de marcadores de erro diretamente no ambiente de desenvolvimento Eclipse IDE. Esta funcionalidade pode apoiar os desenvolvedores na identificação e correção de vulnerabilidades em seu código \cite{CogniCrypt}.

% Por meio da sinergia entre geração de código e análise estática, o CogniCrypt pode conceder aos desenvolvedores uma abordagem completa para lidar com vulnerabilidades em seu código, promovendo o uso seguro de APIs criptográficas \cite{CogniCrypt}.
% FONTES:

% Página 3: "Além de gerar código, o CogniCrypt aplica continuamente uma série de análises estáticas ao projeto do desenvolvedor em segundo plano."
% Página 5: "O CogniCrypt gera exemplos de uso baseados em tarefas para APIs de Cripto Java."
% Página 5: "O CogniCrypt relata usos inadequados gerando marcadores de erro diretamente no lado esquerdo dentro do ambiente de desenvolvimento Eclipse IDE."

% Os desafios enfrentados pelos desenvolvedores ao criar código são diversos e envolvem uma série de complexidades, especialmente quando lidam com sistemas extensos e intricados. Compreender os requisitos, desenhar a arquitetura e implementar o código são tarefas que demandam habilidade e atenção minuciosa. \cite{CogniCrypt}

% A identificação e correção de bugs e erros são etapas cruciais, muitas vezes exigindo um esforço considerável em termos de depuração e resolução de problemas.
% Além disso, a gestão do tempo é uma preocupação constante, pois os desenvolvedores frequentemente trabalham sob prazos apertados. Esta pressão adicional pode tornar desafiador o cumprimento desses prazos, o que, por sua vez, demanda a entrega de código de alta qualidade dentro dos limites estabelecidos.
% A dinamicidade dos requisitos de um projeto ao longo do processo de desenvolvimento pode requerer adaptações e modificações no código, o que, por sua vez, pode gerar trabalho adicional e até mesmo conflitos com o código já existente.
% Em ambientes colaborativos, a efetiva colaboração e comunicação entre membros da equipe são de vital importância. Coordenar esforços, resolver conflitos e assegurar que todos os membros estejam alinhados com os objetivos e metas do projeto pode se configurar como uma tarefa desafiadora, exigindo habilidades de comunicação e gestão de equipe.
% A aprendizagem contínua é um componente essencial no universo do desenvolvimento de software. A necessidade de se manter atualizado em relação a novas tecnologias, linguagens de programação, frameworks e ferramentas é premente. Este processo, embora vital, pode ser demandante em termos de tempo e esforço, requerendo um investimento contínuo por parte dos desenvolvedores.
% Uma vez que o código é desenvolvido, a manutenção contínua se torna imperativa. Esta etapa envolve a correção de bugs, adição de novos recursos e otimização de desempenho. No entanto, a complexidade desta tarefa pode ser exacerbada quando o código não está adequadamente documentado ou quando os desenvolvedores originais não estão mais disponíveis para prestar suporte.
% Por fim, a segurança e garantia de qualidade do código são aspectos cruciais. Os desenvolvedores devem assegurar que seu código seja imune a vulnerabilidades e que siga as melhores práticas para codificação segura. A condução de testes rigorosos se torna essencial para identificar e corrigir possíveis problemas de segurança, garantindo assim a integridade e segurança do software desenvolvido.

Ao integrarmos o CogniCrypt em nossa abordagem, complementando-o com outras ferramentas como o CryptoGuard e o LibScout, queremos fornecer aos desenvolvedores uma estratégia poderosa e abrangente para detectar e corrigir vulnerabilidades em APIs criptográficas Java, seja ela de código nativo ou externo. Isso pode contribuir significativamente para a segurança e integridade dos sistemas desenvolvidos.


% FONTES:

% Página 1: "Por que o software criptográfico falha?: um estudo de caso e problemas em aberto" (Workshop da ACM Ásia-Pacífico em Sistemas)
% Página 1: "Superando obstáculos: por que os desenvolvedores Java têm dificuldade com APIs de criptografia?" (Conferência Internacional sobre Engenharia de Software)
% Página 6: "Por que o software criptográfico falha?: um estudo de caso e problemas em aberto" (Workshop da ACM Ásia-Pacífico em Sistemas)
% Página 6: "Superando obstáculos: por que os desenvolvedores Java têm dificuldade com APIs de criptografia?" (Conferência Internacional sobre Engenharia de Software)

\subsection{O que é a linguagem CrySL?} %CogniCrypt: Supporting Developers in Using Cryptography

A linguagem de especificação criptográfica, ou CrySL, é um componente essencial do ecossistema do CogniCrypt. Ele foi desenvolvido para especificar boas práticas para o uso seguro de APIs criptográficas em Java. A CrySL, que foi desenvolvida como parte integrante do CogniCrypt, permite que os desenvolvedores expressem as regras de segurança de forma simples e fácil de entender, o que facilita a identificação de possíveis vulnerabilidades em códigos que envolvem operações criptográficas. \cite{CogniCrypt}

% A seleção adequada de algoritmos criptográficos, o gerenciamento seguro de chaves e o tratamento adequado de dados sensíveis estão entre as construções de alto nível fornecidas pelo CrySL para descrever cenários comuns de uso de criptografia. Além disso, a linguagem foi desenvolvida para ser flexível, o que permite a inclusão de novas regras à medida que novos padrões e práticas de segurança surgem. \cite{CogniCrypt}

% Os desenvolvedores podem verificar automaticamente se um código está em conformidade com as boas práticas de segurança antes mesmo da execução ao definir regras em CrySL. Isso incentiva uma abordagem proativa para a segurança da informação, evitando brechas de segurança potenciais quando o software é desenvolvido em estágio inicial. \cite{CogniCrypt}

% A linguagem CrySL e o CogniCrypt criam um ambiente poderoso e fácil de entender para o desenvolvimento seguro de aplicações Java. Eles fornecem um conjunto abrangente de diretrizes e ferramentas para proteger dados e sistemas críticos de ameaças cibernéticas. \cite{CogniCrypt}



\subsection{O que é a ferramenta CryptoGuard?}

CRYPTOGUARD é uma ferramenta de verificação de código estático projetada para detectar usos incorretos de APIs criptográficas e SSL/TLS em projetos Java de grande porte. 

Seu propósito é auxiliar os desenvolvedores na identificação e correção de vulnerabilidades relacionadas a algoritmos criptográficos, exposição de segredos, geração previsível de números aleatórios e verificações de certificados vulneráveis. \cite{CryptoGuard} 

O CRYPTOGUARD alcança isso por meio da implementação de um conjunto de novos algoritmos de análise que realizam uma análise estática do código-fonte. 

Ele proporciona detecção de alta precisão de vulnerabilidades criptográficas e oferece insights de segurança aos desenvolvedores. \cite{CryptoGuard} 

% A ferramenta é projetada para ser leve e eficiente, executando mais rapidamente do que técnicas de análise existentes. \cite{CryptoGuard} Suas funcionalidades incluem identificação de violações de propriedades criptográficas, realização de fatiamento para frente e para trás, e geração de alertas de segurança para potenciais vulnerabilidades. \cite{CryptoGuard} O CRYPTOGUARD foi avaliado em 46 projetos Apache e 6.181 aplicativos Android, fornecendo descobertas de segurança valiosas e auxiliando projetos na melhoria de seu código.  \cite{CryptoGuard}

% SOURCES:

% Page 1: "TOGUARD, on 46 high-impact large-scale Apache projects and 6,181 Android apps generate many security insights."
% Page 2: "Our static code checking tool, CRYPTOGUARD, is designed for developers to use routinely on large Java projects."
% Page 2: "CRYPTOGUARD covers more cryptographic properties than CrySL [44], Coverity [1], and SpotBugs [2] combined."
% Page 2: "Our most complex analysis (for Rule 15 on insecure RSA/ECC key sizes) involves multiple rounds of forward and backward slicing."
% Page 8: "Our experimental evaluation aims to answer the following questions... How does CRYPTOGUARD compare with CrySL, SpotBugs, and the free trial version of Coverity on benchmarks or real-world projects?"
% Page 8: "Our findings helped multiple popular Apache projects to harden their code, including Spark, Ranger, and Ofbiz."

O CRYPTOGUARD utiliza algoritmos especializados de fatiamento de programa para sua análise estática. Esses algoritmos de fatiamento são implementados utilizando técnicas de análise de fluxo de dados sensíveis a fluxo, contexto e campo. Os algoritmos de fatiamento são projetados para identificar o conjunto de instruções que influenciam ou são influenciadas por uma variável de programa. \cite{CryptoGuard}

% Os algoritmos de fatiamento utilizados pelo CRYPTOGUARD incluem:

% Fatiamento interprocedural retroativo: Este algoritmo parte de um critério de fatiamento e se propaga retroativamente pelo programa, identificando as instruções que contribuem para o valor do critério de fatiamento. Ele constrói uma coleção ordenada de instruções de todos os métodos visitados. \cite{CryptoGuard}

% Fatiamento retroativo intra-procedural: Semelhante ao fatiamento interprocedural retroativo, este algoritmo opera dentro de um único método. Ele identifica as instruções dentro do método que contribuem para o valor do critério de fatiamento. \cite{CryptoGuard}

% Fatiamento interprocedural progressivo: Este algoritmo identifica as instruções que são influenciadas por um critério de fatiamento em termos de relações de definição e uso. Ele opera nos recortes obtidos a partir do fatiamento retroativo interprocedural. \cite{CryptoGuard}

% Fatiamento progressivo intra-procedural: Este algoritmo é utilizado para sensibilidade de campo sob demanda de classes apenas com dados. Ele identifica as instruções dentro de um método que são influenciadas por um critério de fatiamento, especificamente para classes apenas com dados onde os campos são visíveis apenas em invocações de método ortogonais. \cite{CryptoGuard}

% Esses algoritmos de fatiamento permitem ao CRYPTOGUARD analisar eficientemente projetos Java de grande porte e detectar vulnerabilidades de uso indevido de APIs criptográficas e SSL/TLS. \cite{CryptoGuard}

% Ao usar o Cryptoguard, podemos relatar vários problemas preocupantes de codificação criptográfica em projetos de código aberto Apache e Android. Além disso, incorpora um padrão para comparar a qualidade das ferramentas de detecção de vulnerabilidades criptográficas. \cite{CryptoGuard}

Resumindo, o Cryptoguard é uma ferramenta, assim como o CogniCrypt, para detectar vulnerabilidades criptográficas em projetos Java. 

% FONTES:

% Página 1: CRYPTOGUARD: Detecção de Alta Precisão de Vulnerabilidades Criptográficas em Projetos Java de Tamanho Massivo
% Página 2: CRYPTOGUARD: Detecção de Alta Precisão de Vulnerabilidades Criptográficas em Projetos Java de Tamanho Massivo

% As conclusões de segurança obtidas a partir dos testes com o CRYPTOGUARD em projetos Apache e aplicativos Android incluem o seguinte:

% Projetos Apache:
% Dos 46 projetos Apache avaliados, 39 projetos apresentaram pelo menos um tipo de uso incorreto de criptografia, e 33 projetos tinham pelo menos dois tipos. \cite{CryptoGuard}
% As vulnerabilidades comuns encontradas nos projetos Apache incluíam o uso de chaves previsíveis, funções hash inseguras, geradores de números aleatórios inseguros e a utilização de URLs HTTP. \cite{CryptoGuard}
% O CRYPTOGUARD auxiliou na identificação e relato dessas vulnerabilidades para as equipes do Apache, resultando em correções rápidas em alguns casos. \cite{CryptoGuard}

% Aplicativos Android:
% A avaliação em 6.181 aplicativos Android demonstrou que cerca de 95\% das vulnerabilidades totais originaram-se de bibliotecas empacotadas com o código do aplicativo.\cite{CryptoGuard}
% Bibliotecas de empresas como Google, Facebook, Apache, Umeng e Tencent foram identificadas com violações em diversas categorias, incluindo senhas hardcoded de keyStore e vulnerabilidades SSL/TLS.\cite{CryptoGuard}
% O CRYPTOGUARD detectou múltiplas vulnerabilidades SSL/TLS (MitM) que a triagem automática do Google Play aparentemente deixou passar.\cite{CryptoGuard}

% FONTES:

% Página 2: plataforma de análise de segurança de software livre bem conhecida.
% Página 2: Obtivemos inúmeras percepções de segurança ao avaliar 46 projetos Apache.
% Página 2: Nossa avaliação em 6.181 aplicativos Android mostra que cerca de 95\% das vulnerabilidades totais vêm de bibliotecas empacotadas com o código do aplicativo.

% O estudo sobre o CRYPTOGUARD, ao evidenciar a complexidade na identificação da percepção de vulnerabilidades, assume um papel catalisador para a pesquisa em questão. Ao abordar a detecção de falhas criptográficas em projetos Java, o CRYPTOGUARD não apenas destaca a necessidade premente de compreensão e correção de vulnerabilidades, mas também delineia um terreno propício para a investigação correlata. A pesquisa em pauta visa justamente tentar elucidar as origens das vulnerabilidades identificadas por meio de ferramentas análogas, oferecendo um avanço significativo no entendimento das fragilidades inerentes a sistemas criptográficos. Deste modo, o estudo sobre o CRYPTOGUARD se revela não apenas como um contributo intrínseco ao domínio da segurança cibernética, mas também como um impulso fundamental para a empreitada que visa discernir as fontes subjacentes às vulnerabilidades apresentadas por ferramentas congêneres.


% \subsection{CryptoGuard vs CrySL} %CRYPTOGUARD: High Precision Detection of Cryptographic Vulnerabilities in Massive-sized Java Projects

% A comparação é baseada na precisão e no tempo de execução das ferramentas. \cite{CryptoGuard} Durante os experimentos, o CrySL travou e saiu prematuramente de 7 dos 10 subprojetos raiz do Apache selecionados aleatoriamente. \cite{CryptoGuard} Para os 3 projetos concluídos, o CrySL é mais lento, mas comparável em 2 projetos (5 vs. 3 segundos, 25 vs. 19 segundos). \cite{CryptoGuard} No entanto, é 3 ordens de magnitude mais lento que o Cryptoguard no codec Kerbaros. \cite{CryptoGuard}

% Os falsos positivos do CrySL devem-se principalmente ao fato de suas regras serem excessivamente rígidas e ele não conseguir reconhecer 4 usos corretos da API na avaliação (de 9). \cite{CryptoGuard} Por outro lado, o Cryptoguard usa algoritmos de fatiamento rápidos e altamente precisos para refinar as fatias do programa e reduzir alertas falsos em até 80\%. \cite{CryptoGuard}

